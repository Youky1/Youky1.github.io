---
title: 各类手写问题汇总
category: 面试题
tag:
    - JS

---



# 更改函数this指向的三种方法

## call

1. 函数首先接收上下文参数context，若没有则默认为window

2. 在context上绑定要调用的函数func（也就是this的指向）

3. 截取arguments得到调用函数时要传入的参数

4. 调用后，删除context的func属性

    ```javascript
    Function.prototype.myCall = function(context){
        // 调用者不是函数，报错
        if(typeof this !== 'function'){
            throw new TypeError('调用者不是函数')
        }
    	
        // 若没有传入context，默认值为widow
        context = context || window;
        
        // 获取调用时的参数，即截取掉第一个参数context
        let args = [...arguments].slice(1);
        
        context.func = this;
        let res = context.func(...args);
        
        // 调用后删除func属性
        delete context.func;
        
        // 返回调用结果
        return res;
    }
    ```




## apply

```javascript
Function.prototype.myApply = function(context){
    if(typeof this !== 'function'){
        throw new TypeError('调用者不是函数')
    }
    context = context || window;
    context.fn = this;
    let res = null;
    if(arguments.length > 1){
        res = context.fn(arguments[1]);
    }else{
        res = context.fn();
    }
    delete context.fn;
    return res;
}
```



## bind

```javascript
Function.prototype.myBind = function(context){
    if(typeof this !== 'function'){
        throw new TypeError('调用者不是函数');
    }
    const self = this;
    const args = [...argumnets].slice(1);
    return function f(){
        // 说明f是在当做构造函数调用
        // 参考new一个对象的过程，用new调用时这里的this的__proto__指向f
        if(this instanceof f){
            return new self(...args,...arguments);
        }
        // 当做普通函数调用
        else{
            return self.apply(context,[...args,...arguments])
        }
    }
}
```



# 深拷贝函数

## 最简单的实现

```javascript
JSON.parse(JSON.stringify());
```

问题：

- 不能拷贝函数
- 不能解决**循环引用**问题
- 无法拷贝一些特殊对象，如Map、Set等

## 完整实现

```javascript
/**
 * 深拷贝函数
 * @param {object} data
 * @param {WeakMap<object,boolean>} map
 * @returns {object}
 */
function clone(data, map = new WeakMap()){
	// 非引用类型变量，直接返回
	if(typeof data !== 'object' || data == null || map.get(data)) return data;

	// 在map中记录该变量已经引用过
	map.set(data, true);

	// 判断数据的真实类型
	const type = Object.prototype.toString.call(data).slice(8, -1);
    if(type == 'Data')	return new Date(data);
    else if(type == 'RegExp')	return new RegExp(data);
	else if(type == 'Object' || type == 'Array'){ // 如果是对象或数组
		const res = type == 'Array' ? [] : {};
		for(let key in Reflect.ownKeys(data)){
			res[key] = clone(data[key], map);
		}
		return res;
	}
	else if(type == 'Map'){	// 如果是Map
		const res = new Map();
		for(let key of data.keys()){
			res.set(key, clone(data.get(key), map));
		}
		return res;
	}
	else if(type == 'Set'){ // 如果是Set
		const res = new Set();
		for(let value of data){
			res.add(clone(value, map))
		}
		return res;
	}
}
```



# 实现一个new

```js
function myNew(con, ...args){
    // 如果new后面不是函数类型，则报错
    if(typeof con !== 'function'){
        throw new TypeError(`${con} is not a constructor`)
    }
    // 创建对象，并调用构造函数
    const obj = Object.create(con.prototype);
    const res = con.apply(obj, args);
    // 若构造函数返回了引用类型变量，则返回它；否则返回obj
    return res instanceof Object ? res : obj;
    
}
```



