---
title: 闭包问题
category: 面试题
tag:
    - JS

---



# 基本概念

- Promise共有三种可能的状态，一个Promise只能出现两种：初始化状态、成功状态、失败状态。状态**只能改变一次**
- Promise构造函数中的代码为**同步代码**，回调函数为**微任务**



# Promise为什么能解决回调地狱

## 回调地狱主要代表两个问题

1. 多层嵌套
2. 每个任务的处理结果存在两种可能性，在每种任务结束后都要分别处理这两种情况



## Promise的解决方法

- **回调函数延迟绑定**：回调函数是通过then和catch中声明的
- **返回值穿透**：在回调函数中返回Promise，可以实现链式调用
- **错误冒泡**：前面产生的错误会一直向后传递，被catch接收到，就不必频繁的检查错误了



# then和catch的位置关系

```js
new Promise((resolve, reject) => {
    reject(1)
}).catch(() => {
    console.log(2)
}).then(() => console.log(3))
// 输出2 3
```

```js
new Promise((resolve, reject) => {
    reject(1)
}).then(() => console.log(3))
.catch(() => {
    console.log(2)
})
// 输出2
```

原因：`then`和`catch`执行后都会返回一个promise，所以这两个方法都可以链式调用。catch中只要没有显示抛出错误，其返回的promise都是成功状态



# 其他API



## Promise.resolve

接收一个参数arg，返回一个`resolved`状态的promise实例，arg会作为其成功回调函数的参数。



## Promise.all

- 接收一个元素为promise的数组。返回也是一个promise
- 全部变为成功状态，执行then回调，接收参数为一个数组。
- 只要有一个失败，则立即停止Promise.all的执行，并执行catch回调。



## Promise.race

- 接收一组promise，但只获取第一个执行完毕的实例的状态
