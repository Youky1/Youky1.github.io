(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{599:function(t,a,e){"use strict";e.r(a);var v=e(1),r=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-事件机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-事件机制"}},[t._v("#")]),t._v(" React 事件机制")]),t._v(" "),a("h2",{attrs:{id:"react-中的事件机制是什么样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-中的事件机制是什么样的"}},[t._v("#")]),t._v(" React 中的事件机制是什么样的")]),t._v(" "),a("p",[t._v("React 的事件机制是 合成事件（Synthetic Event），它是对 原生事件的封装。")]),t._v(" "),a("p",[t._v("事件的监听并不绑定在真实的 DOM 元素上，而是绑定在顶层元素上：")]),t._v(" "),a("ul",[a("li",[t._v("React18 之前是 document")]),t._v(" "),a("li",[t._v("React18 开始是 root 元素（避免对外部代码的影响）")])]),t._v(" "),a("p",[t._v("回调函数存储在 DOM 元素对应的 fiber 中，当事件冒泡到顶层元素时，通过 "),a("code",[t._v("event.target")]),t._v(" 确定真实点击的元素，从 target 向上遍历，找到绑定了对应事件的组件，并执行回调")]),t._v(" "),a("h2",{attrs:{id:"和原生事件的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和原生事件的区别"}},[t._v("#")]),t._v(" 和原生事件的区别")]),t._v(" "),a("ul",[a("li",[t._v("React 事件绑定默认是在冒泡阶段触发，不能直接监听 捕获阶段 的事件（但可以通过 onClickCapture 等方式监听）")]),t._v(" "),a("li",[t._v("不能通过 return false 阻止默认行为或事件冒泡（原生事件的该方式只在 onclick 方式绑定时有效）")]),t._v(" "),a("li",[t._v("调用 "),a("code",[t._v("event.stopPropagation")]),t._v(" 只会阻止 React 合成事件的冒泡，而不会阻止原生事件冒泡\n"),a("ul",[a("li",[t._v("阻止原生事件冒泡的方式："),a("code",[t._v("event.nativeEvent.stopImmediatePropagation();")])])])]),t._v(" "),a("li",[t._v("当使用 Portals 时，React 的事件仍按照组件层级冒泡，而非 DOM 结构")])]),t._v(" "),a("h2",{attrs:{id:"为什么要使用这样的事件机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用这样的事件机制"}},[t._v("#")]),t._v(" 为什么要使用这样的事件机制")]),t._v(" "),a("ul",[a("li",[t._v("更好的兼容性：\n"),a("ul",[a("li",[t._v("统一封装原生事件，保证跨浏览器兼容性")])])]),t._v(" "),a("li",[t._v("更好的性能：\n"),a("ul",[a("li",[t._v("事件绑定在 root，减少 DOM 事件监听器")]),t._v(" "),a("li",[t._v("事件对象被复用，避免频繁创建对象")])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);